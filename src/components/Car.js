/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useEffect, useLayoutEffect } from 'react'
import { useFrame, useThree, extend } from '@react-three/fiber'
import { useGLTF, PerspectiveCamera, MeshDistortMaterial, Html } from '@react-three/drei'
import { EffectComposer, SelectiveBloom } from '@react-three/postprocessing'

import * as THREE from 'three'

import useGameState from '../hooks/useGameState'

const v = new THREE.Vector3()

export default function Model(props, { children }) {
  const { nodes, materials } = useGLTF('/models/spaceship.gltf')

  const pointLight = useRef()
  const defaultCamera = useRef()

  const car = useRef()
  const engine = useRef()
  const outerExhaust = useRef()
  const innerExhaust = useRef()

  const { clock } = useThree()

  const leftSpeed = useRef(0)
  const rightSpeed = useRef(0)

  //const [carPos, setCarPos] = useState({ leftSpeed: 0, rightSpeed: 0, position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: Math.PI, z: 0 } })

  useLayoutEffect(() => {
    defaultCamera.current.rotation.set(0, Math.PI, 0)
    defaultCamera.current.position.set(0, 4, -12) // 0, 1.5, -8
    defaultCamera.current.lookAt(v.set(car.current.position.x, car.current.position.y, car.current.position.z + 10 /*10*/)) // modify the camera tracking to look above the center of the car

    defaultCamera.current.rotation.z = Math.PI
    car.current.rotation.y = Math.PI
  }, [])

  useFrame((state, delta) => {
    const bigDelta = delta * 10
    const smallDelta = delta * 5
    const accelDelta = delta / 5

    const { controls: { left, right } } = useGameState.getState()



    if ((left && right) || (!left && !right)) {
      leftSpeed.current = 0
      rightSpeed.current = 0

      // Pos
      if (car.current.position.x > 0 + bigDelta) {
        car.current.position.x -= bigDelta
      } else if (car.current.position.x < 0 - bigDelta) {
        car.current.position.x += bigDelta
      } else {
        car.current.position.x = 0
      }

      // Rot
      if (car.current.rotation.x > 0) {
        car.current.rotation.x -= bigDelta
      } else {
        car.current.rotation.x = 0
      }

      if (car.current.rotation.y > Math.PI + smallDelta) {
        car.current.rotation.y -= smallDelta
      } else if (car.current.rotation.y < Math.PI - smallDelta) {
        car.current.rotation.y += smallDelta
      } else {
        car.current.rotation.y = Math.PI
      }

      if (car.current.rotation.z > 0 + smallDelta) {
        car.current.rotation.z -= smallDelta
      } else if (car.current.rotation.z < 0 - smallDelta) {
        car.current.rotation.z += smallDelta
      } else {
        car.current.rotation.z = 0
      }

      // setCarPos(prev => {

      //   return {
      //     rightSpeed: 0,
      //     leftSpeed: 0,
      //     position: { ...prev.position, x: prev.position.x > 0 ? prev.position.x -= delta * 10 : prev.position.x < 0 ? prev.position.x += delta * 10 : 0 },
      //     rotation: {
      //       x: prev.rotation.x > 0 ? prev.rotation.x -= delta * 10 : 0,
      //       y: prev.rotation.y > Math.PI ?
      //         prev.rotation.y -= delta * 5 :
      //         prev.rotation.y < Math.PI ?
      //           prev.rotation.y += delta * 5 : Math.PI,
      //       z: prev.rotation.z > 0 ? prev.rotation.z -= delta * 5 : prev.rotation.z < 0 ? prev.rotation.z += delta * 5 : 0
      //     }
      //   }
      // })
    }

    if ((left && !right)) {
      rightSpeed.current = 0
      leftSpeed.current += accelDelta

      // pos 
      car.current.position.x = Math.min(1.4, car.current.position.x += leftSpeed.current)

      // rot
      car.current.rotation.x = Math.min(0.1, car.current.rotation.x += bigDelta)
      car.current.rotation.y = Math.min(Math.PI + 0.5, car.current.rotation.y += leftSpeed.current)
      car.current.rotation.z = Math.max(-0.3, car.current.rotation.z -= leftSpeed.current)

      // setCarPos(prev => {
      //   return {
      //     rightSpeed: 0,
      //     leftSpeed: prev.leftSpeed += delta / 2,
      //     position: { ...prev.position, x: Math.min(1.4, prev.position.x += prev.leftSpeed) },
      //     rotation: {
      //       x: Math.min(0.1, prev.rotation.x += delta * 10),
      //       y: Math.min(Math.PI + 0.5, prev.rotation.y += prev.leftSpeed),
      //       z: Math.max(-0.3, prev.rotation.z -= prev.leftSpeed)
      //     }
      //   }
      // })
    }

    if ((!left && right)) {
      rightSpeed.current += accelDelta
      leftSpeed.current = 0

      // pos 
      car.current.position.x = Math.max(-1.4, car.current.position.x -= rightSpeed.current)

      // rot
      car.current.rotation.x = Math.min(0.1, car.current.rotation.x += bigDelta)
      car.current.rotation.y = Math.max(Math.PI - 0.5, car.current.rotation.y -= rightSpeed.current)
      car.current.rotation.z = Math.min(0.3, car.current.rotation.z += rightSpeed.current)

      // setCarPos(prev => {

      //   return {
      //     rightSpeed: prev.rightSpeed += delta / 2,
      //     leftSpeed: 0,
      //     position: { ...prev.position, x: Math.max(-1.4, prev.position.x -= prev.rightSpeed) },
      //     rotation: {
      //       x: Math.min(0.1, prev.rotation.x += delta * 10),
      //       y: Math.max(Math.PI - 0.5, prev.rotation.y -= prev.rightSpeed),
      //       z: Math.min(0.3, prev.rotation.z += prev.rightSpeed)
      //     }
      //   }
      // })
    }

    outerExhaust.current.scale.x = 0.15 + Math.sin(clock.getElapsedTime() * 15) / 15
    outerExhaust.current.scale.y = 0.30 + Math.sin(clock.getElapsedTime() * 10) / 10
    innerExhaust.current.scale.x = 0.10 + Math.sin(clock.getElapsedTime() * 15) / 15
    innerExhaust.current.scale.y = 0.25 + Math.sin(clock.getElapsedTime() * 10) / 10
  })

  // useFrame((state, delta) => {
  //   outerExhaust.current.scale.x = 0.15 + Math.sin(clock.getElapsedTime() * 15) / 15
  //   outerExhaust.current.scale.y = 0.30 + Math.sin(clock.getElapsedTime() * 10) / 10
  //   innerExhaust.current.scale.x = 0.10 + Math.sin(clock.getElapsedTime() * 15) / 15
  //   innerExhaust.current.scale.y = 0.25 + Math.sin(clock.getElapsedTime() * 10) / 10
  //   // car.current.rotation.x = carPos.rotation.x
  //   // car.current.rotation.y = carPos.rotation.y
  //   // car.current.rotation.z = carPos.rotation.z
  //   // car.current.position.x = carPos.position.x
  //   // car.current.position.y = carPos.position.y
  //   // car.current.position.z = carPos.position.z
  // })

  return (
    <group receiveShadow castShadow ref={car} position={[0, 0.87, 0]} {...props} dispose={null}>
      <PerspectiveCamera makeDefault ref={defaultCamera} fov={75} rotation={[0, Math.PI, 0]} position={[0, 10, -20]} />
      <pointLight ref={pointLight} color="lightpink" decay={4} distance={50} intensity={5} position={[0, 0, -2]} />
      {children}
      <mesh geometry={nodes.Ship_Body.geometry} material={materials.Cockpit} />
      <mesh geometry={nodes.Ship_Body_1.geometry} material={materials.Chassis} />
      <mesh ref={engine} geometry={nodes.Ship_Body_2.geometry}>
        <meshBasicMaterial attach="material" color="orange" />
      </mesh>
      <mesh geometry={nodes.Ship_Body_3.geometry} material={materials['Gray Metal']} />
      <mesh geometry={nodes.Ship_Body_4.geometry}>
        <meshBasicMaterial attach="material" color="lightpink" />
      </mesh>
      <mesh ref={outerExhaust} scale={[0.1, 0.05, 2]} position={[0, -0.3, -4.5]}>
        <dodecahedronBufferGeometry args={[1.5, 3]} />
        <MeshDistortMaterial speed={2} distort={0.2} radius={1} transparent opacity={0.6} color="red" />
      </mesh>
      <mesh ref={innerExhaust} scale={[0.1, 0.05, 2]} position={[0, -0.3, -4.5]}>
        <dodecahedronBufferGeometry args={[1.5, 3]} />
        <meshBasicMaterial color="white" />
      </mesh>
    </group>
  )
}


useGLTF.preload('/models/spaceship.gltf')




